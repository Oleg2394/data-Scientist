#!/usr/bin/env python
# coding: utf-8

# ### Урок 4.5: структурированные списки

# До этого мы работали с обычными массивами, массивами, где у нас не было никаких меток, которые бы сообщали, что именно содержится в том или ином списке: возраст человека, его доход, пол и прочее. Мы уже заранее знали, что, например, в массиве `scores` сохранены оценки студентов и больше ничего. Кроме того, мы не могли бы включить в список имена студентов как есть, ведь массив не может содержать элементы разных типов, в нашем случае, целые числа и строки. Как быть? Можно создать структурированный массив или структурированный список (*structured array*). 
# 
# Чтобы познакомиться с этой структурой, рассмотрим пример. У нас есть данные по трем людям: имя (строка), возраст (целое число) и рост (число с плавающей точкой). Мы хотим создать массив таким образом, чтобы было понятно, что в нем сохранены именно такие показатели, плюс, чтобы разные типы данных не конфликтовали между собой. Попробуем! 

# In[2]:


import numpy as np


# In[3]:


info = np.array([('Anna', 19, 168), 
                 ('Sam', 33, 175.5), 
                 ('Pam', 23, 180)],
             dtype=[('name', 'U10'), 
                    ('age', int), 
                    ('height', float)])


# Для удобства можно думать о массиве `info` как о таблице с данными, в которой есть 3 столбца (`name`, `age`, `height`) и три строки, соответствующие трём респондентам (*Anna*, *Sam*, *Pam*). 
# 
# Что приведенный выше код означает? Во-первых, данные по каждому человеку мы записали в виде кортежа – набора элементов в круглых скобках, причем перечислили имя, возраст и рост друг за другом. Каждый кортеж – это одна строка в таблице. Во-вторых, каждому значению в кортеже мы присвоили название: в `dtype` у нас указано три элемента. Первый элемент имеет название или метку `name`, второй – `age`, третий – `height`. 
# В-третьих, чтобы Python не привёл все элементы к одному типу (строковый тип, *string*, окажется сильнее, поэтому есть риск превратить все числовые значения в массиве в текст), в `dtype`, помимо названия поля, то есть столбца в таблице, мы указываем его тип. Тип 
# 
# Посмотрим на  массив:

# In[4]:


info


# In[5]:


print(info)


# Обращаться к элементам структурированного массива можно обычным образом. Так, выведем на экран информацию по Анне, которая у нас находится на первом месте в массиве:

# In[6]:


info[0]


# Или информацию по Анне и Сэму сразу, используя срез:

# In[7]:


info[0:2]


# Однако история со структурированными массивами ещё более интересная. Можно отдельно вызывать определенные поля – значения с фиксированной меткой или названием. Так, мы можем запросить значения возраста по всем людям в массиве:

# In[8]:


info['age']


# Или пары возраст-рост:

# In[9]:


info[['age', 'height']]  # названия оформлены в виде списка - в []


# Отсюда можем получить информацию по первому человеку (Анне):

# In[10]:


info[['age', 'height']][0]


# Или отдельно по второму (Сэм):

# In[11]:


info[['age', 'height']][1]


# **Дополнение для желающих**
# 
# Изменять элементы структурированного массива тоже можно. И логика ничем не отличается от работы с обычными массивами. Заменим третий элемент массива: вместо данных по Пэм запишем данные по Стиву:

# In[12]:


info[2] = ('Steve', 34, 172)  # в виде кортежа


# In[13]:


info


# А теперь изменим возраст Анны (допустим, мы ошиблись ранее и указали возраст не той Анны):

# In[14]:


info['age'][0] = 25
info

