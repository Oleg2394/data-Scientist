#!/usr/bin/env python
# coding: utf-8

# ## Библиотека `pandas` (часть 2)

# ### Урок 6.1. Применение функций и метод `.apply()`
# 
# В этом модуле мы продолжим работать с библиотекой `pandas` и поговорим о более продвинутых способах обработки данных с помощью этой библиотеки. Но прежде чем обсуждать различные методы, давайте загрузим небольшой датасет из csv-файла. Формат *csv* расшифровывается как *comma separated values*, данные хранятся в текстовом виде, и столбцы отделяются друг от друга запятыми.
# 
# Датасет содержит информацию о том, как люди сбрасывали вес в течение 3 месяцев с применением различных методик, и как при этом менялась их самооценка. Давайте сначала загрузим файл в Jupyter. (Показать, как загрузить файл через *Upload* в *Home* в рабочую папку).

# In[1]:


import pandas as pd
import numpy as np  # тоже пригодится
df = pd.read_csv("WeightLoss.csv")


# In[2]:


df.head()


# **Переменные:**
# 
# * `group`: экспериментальная группа: контрольная (`Control`), диета (`Diet`), диета и упражнения `DietEx`;
# 
# * `w1`: потеря веса после 1-го месяца эксперимента;
# 
# * `w2`: потеря веса после 2-го месяца эксперимента;
# 
# * `w3`: потеря веса после 3-го месяца эксперимента;
# 
# * `se1`: самооценка после 1-го месяца эксперимента;
# 
# * `se2`: самооценка после 2-го месяца эксперимента;
# 
# * `se3`: самооценка после 3-го месяца эксперимента.

# Прежде чем переходить к обсуждению методов, которые позволяют применять функции к столбцам или строкам датафрейма, давайте вспомним, как добавить новые столбцы на основе старых в датафрейм. Создадим столбец `total` с общим числом килограммов, потерянных за три месяца, а потом на его основе создадим столбец с той же информацией, но уже с граммах:

# In[3]:


df['total'] = df['w1'] + df['w2'] + df['w3']
df['total_gr'] = df['total'] * 1000
df.head()


# Если бы у нас было много столбцов (например, данные были бы не за 3 месяца, а за 12 или 24), складывать их «вручную» было бы неудобно. Поэтому у нас, скорее всего, возникло бы желание выбрать столбцы через срез и применить к ним какую-нибудь готовую функцию. В `pandas` это можно сделать с помощью `.apply()`. Давайте с ним познакомимся пока на примере попроще, применительно к одному столбцу. Например, логарифмируем значения в столбце `total_gr`. Для этого нам нужно выбрать сам столбец, действия с которым нас интересуют, дописать к нему метод `.apply()`, от английского «применять» и указать внутри скобок, в качестве аругмента, функцию, котоая будет реализовывать желаемую операцию:

# In[4]:


df['total_gr'].apply(np.log)  # применяем log из numpy


# Получился новый столбец, новый объект типа `pandas Series`. Можно было бы добавить его в датасет, но такие вещи мы делать уже умеем и так, поэтому давайте перейдем к более интересной задаче: добавим столбец, в котором будет сохранены значения средней потери веса за три месяца по каждому человеку. Выберем в помощью `.loc` и текстового среза нужные столбцы и применим к ним функцию `mean` для среднего, плюс, укажем, что эта функция должна применяться по строкам, то есть среднее значение должно считаться по каждому человеку:

# In[5]:


df['avloss'] = df.loc[:,'w1':'w3'].apply(np.mean, axis=1)
df.head()


# Если бы мы написали `axis=0`, то получили бы среднюю потерю веса по всем людям за каждый месяц (три значения):

# In[6]:


df.loc[:,'w1':'w3'].apply(np.mean, axis=0)


# Самое интересное и полезное: в `.apply()` можно прописывать свои функции, которые мы заранее определим. Напишем функцию, которая будет считать размах: вычитать из максимального значения минимальное и возвращать результат. Напишем небольшую lambda-функцию в Python и назовём её `f`. Мы не обсуждали отдельно написание собственных функций, но lambda-функции устроены несложно. Сначала мы указываем название функции, потом после знака равенства начинаем её определять. Стартуем с ключевого слова `lambda`, чтобы Python понимал, что это функция. После указываем аргумент – то, с чем функция должна работать, то, что подаётся ей на вход. Назвать его мы можем как угодно, у нас будет `x`. Далее через двоеточие мы прописываем, что с этим `x` нужно сделать, то есть вернуть на выходе, в результате исполнения функции.

# In[7]:


f = lambda x: x.max() - x.min()


# Здесь `x` – это какой-то перечень значений, по нему мы считаем минимум и максимум, а потом из одного вычитаем другое. Применим написанную нами функцию к тем же столбцам и скажем, что опять функция должна применяться по строкам – к каждому человеку:

# In[8]:


df['wrange'] = df.loc[:,'w1':'w3'].apply(f, axis=1)
df.head()


# Что получилось? Для каждого участника была посчитана максимальная потеря веса за 3 месяца, потом минимальная, посчитан результат и сохранён в отдельный столбец `wrange`.
